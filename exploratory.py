from bs4 import BeautifulSoup
import pandas as pd
import plotly.express as px
from datetime import datetime
import re
import requests
from tqdm import tqdm
import numpy as np

'''
{'Name': 'eerste_divisie', 'Teams': 20}
{'Name': 'segunda_liga', 'Teams': 20}
Eerste divisie and segunda_liga discarded for lack of data
'''
leagues = [{'Name': 'eredivisie', 'Teams': 20},
           {'Name': 'eerste_divisie', 'Teams': 20},
           {'Name': 'ligue_2', 'Teams': 20},
           {'Name': 'serie_a', 'Teams': 20},
           {'Name': 'championship', 'Teams': 24},
           {'Name': 'premier_league', 'Teams': 20},
           {'Name': 'segunda_liga', 'Teams': 20},
           {'Name': 'bundesliga', 'Teams': 18},
           {'Name': 'ligue_1', 'Teams': 20},
           {'Name': '2_liga', 'Teams': 18},
           {'Name': 'primeira_liga', 'Teams': 18},
           {'Name': 'segunda_division', 'Teams': 22},
           {'Name': 'serie_b', 'Teams': 20},
           {'Name': 'primera_division', 'Teams': 20}]

years = list(range(1990, 2023))


class DataCleaner:
    '''
    This is a class containing tools to "clean" the information about
    each match stored across the csv files for each year of each
    respective football league and return a large dataset of useful
    information about each match.
    Attribute:
        leagues(List of Strings): A set of strings corresponding to the leagues
        to be cleaned. Ideally, this should be every league contained in
        the csvs but some data may need to redacted if misleading.
        years(List of Integers): A list of the years to be cleaned. This
        can be edited as it may only be advantageous to clean recent years.
    '''

    def __init__(self, leagues, years) -> None:
        '''
        See help(DataCleaner) for accurate signature.
        '''
        self.leagues = leagues
        self.years = years

    def find_winners(self, dataframe):
        '''
        This function is used to create a column in the dataframe of football
        matches listing which team won that game. It inserts the winning
        side's team name into the column or None in the case of a draw.
        Attribute:
            dataframe(pd.DataFrame): The dataframe of football matches
            generated by the clean data function.
        '''
        Results = []
        Winners = []
        Losers = []
        for i in range(len(dataframe)):
            if dataframe['Home_Team_Goals'][i] > dataframe[
                    'Away_Team_Goals'][i]:
                Results.append('Home_Team_Win')
                Winners.append(dataframe['Home_Team'][i])
                Losers.append(dataframe['Away_Team'][i])
            elif dataframe['Home_Team_Goals'][i] == \
                    dataframe['Away_Team_Goals'][i]:
                Results.append('Draw')
                Winners.append(None)
                Losers.append(None)
            else:
                Results.append('Away_Team_Win')
                Winners.append(dataframe['Away_Team'][i])
                Losers.append(dataframe['Home_Team'][i])
        return Results, Winners, Losers

    def clean_data(self, league, year):
        '''
        A function to read the data in a csv file for one season of one league.
        Some basic columns are added as well from the data including the number
        of goals scored by both sides, and columns stating the winning team,
        the losing team, and the result of the match.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            year(Integer): The year of the later half of the season that the
            function is to read the data of.
        '''
        league_to_read = league
        df = pd.read_csv(f'data/{league}/Results_{year}_{league}.csv')

        league_teams = teams_in_league(self.leagues, league_to_read)

        Home_Team_Goals = [int(df['Result'][x].split(
            '-')[0]) for x in range(len(df))]

        Away_Team_Goals = [int(df['Result'][x].split(
            '-')[1]) for x in range(len(df))]

        df['Teams_in_League'] = league_teams
        df['Home_Team_Goals'] = Home_Team_Goals
        df['Away_Team_Goals'] = Away_Team_Goals
        df['Result'], df['Winners'], df['Losers'] = self.find_winners(df)
        return df

    def histogram(self, league, year):
        '''
        This is a function to produce a histogram of the number of games won
        by each team in one season of one league. This is for
        exploratory purposes to determine the best and worst teams by
        performance and the range of wins to losses between teams.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            year(Integer): The year of the later half of the season that the
            function is to read the data of.
        '''
        df = self.clean_data(league, year)
        fig = px.histogram(df, "Result",
                           title="Wins by Home and Away Teams {} {}".format(
                               str(df.League[0]), str(df.Season[0])),
                           text_auto=True, histnorm='percent')
        fig.update_xaxes(categoryorder='category descending')
        fig.show()

    def bar_graph(self, league, year):
        '''
        This is a function to produce a bar graph of the number of games won
        and lost by each team in one season of one league. This is for
        exploratory purposes to determine the best and worst teams by
        performance and the range of wins to losses between teams.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            year(Integer): The year of the later half of the season that the
            function is to read the data of.
        '''
        df = self.clean_data(league, year)
        fig = px.bar(df.loc[:, ['Winners', 'Losers']], barmode='group',
                     title='Games Won and Lost by Team')
        fig.update_xaxes(categoryorder='category ascending')
        fig.show()

    def wp_graph(self, league, years):
        '''
        This is a function to produce a graph of the top teams win
        percentage in one season of one league. This is for
        exploratory purposes to determine the best teams in the league
        each season by win percentage.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of strings. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df_wp = self.win_percentage_over_time(league, years)
        fig = px.bar(df_wp, x='Year', y='WP',
                     title='Top teams win percentage over time - {}'.format(
                         league), text_auto=True)
        fig.update_xaxes(categoryorder='category descending')
        fig.show()

    def find_wins_losses_draws(self, df, team):
        '''
        This is a function to search through a dataframe of games of
        one season in one year and find the total number of one team's
        wins, losses, and draws.
        Attributes:
            df(pd.DataFrame): The dataframe of football matches
            generated by the clean data function.
            team(String): The name of the team to find wins, losses,
            and draws for in a specific season.
        '''
        games_played = sum(df['Home_Team'] == team) + \
            sum(df['Away_Team'] == team)
        games_won = sum(df['Winners'] == team)
        games_lost = sum(df['Losers'] == team)
        games_drawn = games_played - games_won - games_lost
        return games_won, games_lost, games_drawn

    def find_most_wins(self, df):
        '''
        This is a function to identify the team with the most wins in
        one season
        Attributes:
            df(pd.DataFrame): The dataframe of football matches
            generated by the clean data function.
        '''
        return df['Winners'].value_counts().to_frame().iloc[0].name

    def find_win_percentage(self, wins, losses, draws):
        '''
        This is a function to calculate win percentages from inputted
        wins, losses and draws.
        Attributes:
            wins(Integer): The number of wins by a team in one season.
            draws(Integer): The number of draws by a team in one season.
            losses(Integer): The number of losses by a team in one season.
        '''
        return wins / (wins + losses + draws)

    def find_top_win_percentage(self, df):
        '''
        This is a function to find the win percentage of the team with the
        most wins in one season of a football league.
        Attributes:
            df(pd.DataFrame): The dataframe of football matches
            generated by the clean data function.
        '''
        winner = self.find_most_wins(df)
        wld = self.find_wins_losses_draws(df, winner)
        wp = self.find_win_percentage(wld[0], wld[1], wld[2])
        return wp

    def win_percentage_over_time(self, league, years):
        '''
        This is a function to find the win percentage over a number of years
        of the team with the most wins in one season of a
        football league.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of strings. The years of the later halves of
            each season that the function is to read the data of.
        '''
        list_of_wins = []
        for year in years:
            df = self.clean_data(league, year)
            if df.empty:
                pass
            else:
                list_of_wins.append(
                    {'Year': df['Season'][0], 'WP': self.
                     find_top_win_percentage(df)})
        df_wp = pd.DataFrame(list_of_wins)
        return df_wp

    def calculate_league_table(self, league, year):
        '''
        This is a function to generate the league table after the end of the
        season of a football league in a specified year.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            year(Integer): The year of the later half of the season that the
            function is to read the data of.
        '''
        df = self.clean_data(league, year)
        teams = df['Home_Team'].drop_duplicates()
        league_table = []
        for team in teams:
            wld = self.find_wins_losses_draws(df, team)
            points = 3 * wld[0] + wld[2]
            league_table.append({'Team': team, 'Points': points})
        return pd.DataFrame(league_table).sort_values(
            'Points', ascending=False)

    def find_wins_losses_draws_by_round(self, df, team, round):
        '''
        This is a function to search through a dataframe of games of
        one season in one year and find the total number of one team's
        wins, losses, and draws before a specified round of that season.
        Attributes:
            df(pd.DataFrame): The dataframe of football matches
            generated by the clean data function.
            team(String): The name of the team to find wins, losses,
            and draws for in that season.
            round(Integer): The number of the round before which games
            should be considered.
        '''
        df = df[df['Round'] < round]
        if df.empty:
            return 0, 0, 0
        else:
            games_played = sum(df['Home_Team'] == team) + \
                sum(df['Away_Team'] == team)
            games_won = sum(df['Winners'] == team)
            games_lost = sum(df['Losers'] == team)
            games_drawn = games_played - games_won - games_lost
            return games_won, games_lost, games_drawn

    def calculate_league_table_by_round(self, league, year, round):
        '''
        This is a function to generate the league table after the end of the
        season of a football league in a specified year at a specified point
        in the season.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            year(Integer): The year of the later half of the season that the
            function is to read the data of.
            round(Integer): The number of the round before which games
            should be considered.
        '''
        df = self.clean_data(league, year)
        teams = df['Home_Team'].drop_duplicates()
        league_table = []
        for team in teams:
            wld = self.find_wins_losses_draws_by_round(df, team, round)
            points = 3 * wld[0] + wld[2]
            league_table.append({'Team': team, 'Points': points})
        return pd.DataFrame(league_table).sort_values(
            'Points', ascending=False)

    def add_elo(self, league, years):
        '''
        This is a function to add every team's elo rating to the table
        created by the add_elo function. This also modifies the link column
        for use as a database ID.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.clean_data(league, years)
        if 'Elo_home' not in df:
            elo = pd.read_pickle('elo_dict.pkl')
            elo = pd.DataFrame.from_dict(elo, orient='index')
            elo.index.name = 'Link'
            new_df = pd.merge(df, elo, on='Link')
        else:
            new_df = df
        Link = [modify_link(new_df['Link'][x]) for x in range(len(new_df))]
        new_df['Link'] = Link
        return new_df

    def add_gf_thus_far(self, league, years):
        '''
        This is a function to add each team's goals scored so far to the table
        created by the add_elo function.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_elo(league, years)
        teams = df['Home_Team'].drop_duplicates()
        if df.empty:
            df['Home_Team_Goals_For_This_Far'] = np.NaN
            df['Away_Team_Goals_For_This_Far'] = np.NaN
        else:
            for team in teams:
                goals = [0]
                mini_df = team_table(df, team)
                for row, value in mini_df.iterrows():
                    if value['Home_Team'] == team and goals:
                        goals.append(goals[-1] + value['Home_Team_Goals'])
                    elif value['Home_Team'] == team:
                        goals.append(value['Home_Team_Goals'])
                    elif value['Away_Team'] == team and goals:
                        goals.append(goals[-1] + value['Away_Team_Goals'])
                    else:
                        goals.append(value['Away_Team_Goals'])
                for location, goal_tally in zip(mini_df.index.values,
                                                goals[:-1]):
                    if df.loc[int(location)]['Home_Team'] == team:
                        df.at[int(location), 'Home_Team_Goals_For_This_Far'
                              ] = goal_tally
                    else:
                        df.at[int(location), 'Away_Team_Goals_For_This_Far'
                              ] = goal_tally
        return df

    def add_ga_thus_far(self, league, years):
        '''
        This is a function to add each team's goals conceded so far
        to the table created by the add_gf_thus_far function.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_gf_thus_far(league, years)
        teams = df['Home_Team'].drop_duplicates()
        df.insert(13, 'Home_Team_Goals_Against_This_Far', [None] * len(df))
        df.insert(15, 'Away_Team_Goals_Against_This_Far', [None] * len(df))
        for team in teams:
            goals = [0]
            mini_df = team_table(df, team)
            for row, value in mini_df.iterrows():
                if value['Home_Team'] == team:
                    goals.append(goals[-1] + value['Away_Team_Goals'])
                else:
                    goals.append(goals[-1] + value['Home_Team_Goals'])
            for location, goal_tally in zip(mini_df.index.values, goals[:-1]):
                if df.loc[int(location)]['Home_Team'] == team:
                    df.at[int(location),
                          'Home_Team_Goals_Against_This_Far'] = goal_tally
                else:
                    df.at[int(location),
                          'Away_Team_Goals_Against_This_Far'] = goal_tally
        return df

    def add_unbeaten_streak(self, league, years):
        '''
        This is a function to add each team's unbeaten streak to the table
        created by the add_ga_thus_far function.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_ga_thus_far(league, years)
        teams = df['Home_Team'].drop_duplicates()
        df.insert(16, 'Home_Team_Unbeaten_Streak', [None] * len(df))
        df.insert(17, 'Away_Team_Unbeaten_Streak', [None] * len(df))
        for team in teams:
            streak = [0]
            mini_df = team_table(df, team)
            for row, value in mini_df.iterrows():
                if value['Winners'] in [None, team]:
                    streak.append(streak[-1] + 1)
                else:
                    streak.append(0)
            for location, streak_tally in zip(
                    mini_df.index.values, streak[:-1]):
                if df.loc[int(location)]['Home_Team'] == team:
                    df.at[int(location),
                          'Home_Team_Unbeaten_Streak'] = streak_tally
                else:
                    df.at[int(location),
                          'Away_Team_Unbeaten_Streak'] = streak_tally
        return df

    def add_winning_streak(self, league, years):
        '''
        This is a function to add each team's winning streak to the table
        created by the add_unbeaten_streak function.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_unbeaten_streak(league, years)
        teams = df['Home_Team'].drop_duplicates()
        for team in teams:
            streak = [0]
            mini_df = team_table(df, team)
            for row, value in mini_df.iterrows():
                if value['Winners'] == team:
                    streak.append(streak[-1] + 1)
                else:
                    streak.append(0)
            for location, streak_tally in zip(
                    mini_df.index.values, streak[:-1]):
                if df.loc[int(location)]['Home_Team'] == team:
                    df.at[int(location),
                          'Home_Team_Winning_Streak'] = streak_tally
                else:
                    df.at[int(location),
                          'Away_Team_Winning_Streak'] = streak_tally
        return df

    def add_losing_streak(self, league, years):
        '''
        This is a function to add each team's losing streak to the table
        created by the add_winning_streak function.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_winning_streak(league, years)
        teams = df['Home_Team'].drop_duplicates()
        df.insert(16, 'Home_Team_Losing_Streak', [None] * len(df))
        df.insert(17, 'Away_Team_Losing_Streak', [None] * len(df))
        for team in teams:
            streak = [0]
            mini_df = team_table(df, team)
            for row, value in mini_df.iterrows():
                if value['Losers'] == team:
                    streak.append(streak[-1] + 1)
                else:
                    streak.append(0)
            for location, streak_tally in zip(
                    mini_df.index.values, streak[:-1]):
                if df.loc[int(location)]['Home_Team'] == team:
                    df.at[int(location),
                          'Home_Team_Losing_Streak'] = streak_tally
                else:
                    df.at[int(location),
                          'Away_Team_Losing_Streak'] = streak_tally
        return df

    def add_points(self, league, years):
        '''
        This is a function to add each team's point total to the table
        created by the add_losing_streak function.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_losing_streak(league, years)
        teams = df['Home_Team'].drop_duplicates()
        df.insert(16, 'Home_Team_Points', [None] * len(df))
        df.insert(17, 'Away_Team_Points', [None] * len(df))
        for team in teams:
            streak = [0]
            mini_df = team_table(df, team)
            for row, value in mini_df.iterrows():
                if value['Winners'] == team:
                    streak.append(streak[-1] + 3)
                elif value['Winners'] is None:
                    streak.append(streak[-1] + 1)
                else:
                    streak.append(streak[-1])
            for location, points_tally in zip(
                    mini_df.index.values, streak[:-1]):
                if df.loc[int(location)]['Home_Team'] == team:
                    df.at[int(location),
                          'Home_Team_Points'] = points_tally
                else:
                    df.at[int(location),
                          'Away_Team_Points'] = points_tally
        return df

    def clean_match_info(self, match_info_csv):
        '''
        This is a function to convert the data in the match_info.csv file into
        useful data before it is joined to the larger dataset of each football
        match.
        Attributes:
            match_info_csv(String): The location of the match_info_csv
            file in the filesystem.
        '''
        match_info = pd.read_csv(match_info_csv)
        Link = [update_link(match_info['Link'][x])
                for x in range(len(match_info))]
        Date = [change_date(match_info['Date_New'][x])
                for x in range(len(match_info))]
        Home_Team = [match_info['Link'][x].split(
            '/')[2] for x in range(len(match_info))]
        Away_Team = [match_info['Link'][x].split(
            '/')[3] for x in range(len(match_info))]
        Year = [int(match_info['Link'][x].split(
            '/')[4]) for x in range(len(match_info))]
        Referee = [clean_ref(match_info['Referee'][x])
                   for x in range(len(match_info))]
        match_info['Date_New'] = Date
        match_info['Link'] = Link
        match_info['Home_Team'] = Home_Team
        match_info['Away_Team'] = Away_Team
        match_info['Year'] = Year
        match_info['Referee'] = Referee
        match_info.drop('Home_Team', axis=1, inplace=True)
        match_info.drop('Away_Team', axis=1, inplace=True)
        match_info.fillna(0, inplace=True)
        return match_info

    def add_cards(self, league, years):
        '''
        This is a function to add each team's card totals to the table
        created by the add_points function. It creates columns for each side's
        yellow and red cards received each match.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        match_info = self.clean_match_info('Match_Info.csv')
        df = self.add_points(league, years)
        if 'Home_Red' not in df:
            df = pd.merge(df, match_info, on='Link')
        teams = df['Home_Team'].drop_duplicates().to_list()
        if df.empty:
            df['Home_Team_Reds_This_Far'] = np.NaN
            df['Home_Team_Yellows_This_Far'] = np.NaN
            df['Away_Team_Reds_This_Far'] = np.NaN
            df['Away_Team_Yellows_This_Far'] = np.NaN
        else:
            for team in teams:
                yellows = [0]
                reds = [0]
                mini_df = team_table(df, team)
                for row, value in mini_df.iterrows():
                    if value['Home_Team'] == team:
                        try:
                            yellows.append(
                                int(yellows[-1] + value['Home_Yellow']))
                            reds.append(int(reds[-1] + value['Home_Red']))
                        except ValueError:
                            yellows = [0] * len(mini_df)
                            reds = [0] * len(mini_df)
                            break
                    else:
                        try:
                            yellows.append(
                                int(yellows[-1] + value['Away_Yellow']))
                            reds.append(int(reds[-1] + value['Away_Red']))
                        except ValueError:
                            yellows = [0] * len(mini_df)
                            reds = [0] * len(mini_df)
                            break
                for location, yellow, red in zip(
                        mini_df.index.values, yellows[:-1], reds[:-1]):
                    if df.loc[int(location)]['Home_Team'] == team:
                        df.at[int(location), 'Home_Team_Reds_This_Far'
                              ] = red
                        df.at[int(location), 'Home_Team_Yellows_This_Far'
                              ] = yellow
                    else:
                        df.at[int(location), 'Away_Team_Reds_This_Far'
                              ] = red
                        df.at[int(location), 'Away_Team_Yellows_This_Far'
                              ] = yellow
        return df

    def add_wdl(self, league, years):
        '''
        This is a function to add each team's win, draw, and loss totals to
        the table created by the add_cards function.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_cards(league, years)
        teams = df['Home_Team'].drop_duplicates().to_list()
        for team in teams:
            wins = [0]
            draws = [0]
            losses = [0]
            mini_df = team_table(df, team)
            for row, value in mini_df.iterrows():
                if value['Winners'] == team:
                    wins.append(wins[-1] + 1)
                    draws.append(draws[-1])
                    losses.append(losses[-1])
                elif value['Losers'] == team:
                    wins.append(wins[-1])
                    draws.append(draws[-1])
                    losses.append(losses[-1] + 1)
                else:
                    wins.append(wins[-1])
                    draws.append(draws[-1] + 1)
                    losses.append(losses[-1])
            for location, win, draw, loss in zip(
                    mini_df.index.values, wins[:-1], draws[:-1], losses[:-1]):
                if df.loc[int(location)]['Home_Team'] == team:
                    df.at[int(location), 'Home_Wins_This_Far'
                          ] = win
                    df.at[int(location), 'Home_Draws_This_Far'
                          ] = draw
                    df.at[int(location), 'Home_Losses_This_Far'
                          ] = loss
                else:
                    df.at[int(location), 'Away_Wins_This_Far'
                          ] = win
                    df.at[int(location), 'Away_Draws_This_Far'
                          ] = draw
                    df.at[int(location), 'Away_Losses_This_Far'
                          ] = loss
        return df

    def add_sided_wdl(self, league, years):
        '''
        This is a function to add each team's win, draw, and loss totals at
        home and away to the table created by the add_wdl function. This is
        an important distinction as it offers information on how a team
        performs differently at home and away.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_wdl(league, years)
        teams = df['Home_Team'].drop_duplicates().to_list()
        for team in teams:
            h_wins = [0]
            h_draws = [0]
            h_losses = [0]
            a_wins = [0]
            a_draws = [0]
            a_losses = [0]
            mini_df = team_table(df, team)
            for row, value in mini_df.iterrows():
                if value['Winners'] == team:
                    if value['Home_Team'] == team:
                        h_wins.append(h_wins[-1] + 1)
                        h_draws.append(h_draws[-1])
                        h_losses.append(h_losses[-1])
                        a_wins.append(a_wins[-1])
                        a_draws.append(a_draws[-1])
                        a_losses.append(a_losses[-1])
                    else:
                        h_wins.append(h_wins[-1])
                        h_draws.append(h_draws[-1])
                        h_losses.append(h_losses[-1])
                        a_wins.append(a_wins[-1] + 1)
                        a_draws.append(a_draws[-1])
                        a_losses.append(a_losses[-1])
                elif value['Losers'] == team:
                    if value['Home_Team'] == team:
                        h_wins.append(h_wins[-1])
                        h_draws.append(h_draws[-1])
                        h_losses.append(h_losses[-1] + 1)
                        a_wins.append(a_wins[-1])
                        a_draws.append(a_draws[-1])
                        a_losses.append(a_losses[-1])
                    else:
                        h_wins.append(h_wins[-1])
                        h_draws.append(h_draws[-1])
                        h_losses.append(h_losses[-1])
                        a_wins.append(a_wins[-1])
                        a_draws.append(a_draws[-1])
                        a_losses.append(a_losses[-1] + 1)
                else:
                    if value['Home_Team'] == team:
                        h_wins.append(h_wins[-1])
                        h_draws.append(h_draws[-1] + 1)
                        h_losses.append(h_losses[-1])
                        a_wins.append(a_wins[-1])
                        a_draws.append(a_draws[-1])
                        a_losses.append(a_losses[-1])
                    else:
                        h_wins.append(h_wins[-1])
                        h_draws.append(h_draws[-1])
                        h_losses.append(h_losses[-1])
                        a_wins.append(a_wins[-1])
                        a_draws.append(a_draws[-1] + 1)
                        a_losses.append(a_losses[-1])
            for location, hwin, hdraw, hloss, awin, adraw, aloss in zip(
                    mini_df.index.values, h_wins[:-1], h_draws[:-1],
                    h_losses[:-1], a_wins[:-1], a_draws[:-1], a_losses[:-1]):
                if df.loc[int(location)]['Home_Team'] == team:
                    df.at[int(location), 'Home_Wins_This_Far_at_Home'
                          ] = hwin
                    df.at[int(location), 'Home_Draws_This_Far_at_Home'
                          ] = hdraw
                    df.at[int(location), 'Home_Losses_This_Far_at_Home'
                          ] = hloss
                    df.at[int(location), 'Home_Wins_This_Far_Away'
                          ] = awin
                    df.at[int(location), 'Home_Draws_This_Far_Away'
                          ] = adraw
                    df.at[int(location), 'Home_Losses_This_Far_Away'
                          ] = aloss
                else:
                    df.at[int(location), 'Away_Wins_This_Far_at_Home'
                          ] = hwin
                    df.at[int(location), 'Away_Draws_This_Far_at_Home'
                          ] = hdraw
                    df.at[int(location), 'Away_Losses_This_Far_at_Home'
                          ] = hloss
                    df.at[int(location), 'Away_Wins_This_Far_Away'
                          ] = awin
                    df.at[int(location), 'Away_Draws_This_Far_Away'
                          ] = adraw
                    df.at[int(location), 'Away_Losses_This_Far_Away'
                          ] = aloss
        return df

    def add_per_games(self, league, years):
        '''
        This is a function to add each team's statistics per game to
        the table created by the add_sided_wdl function.
        Attributes:
            league(String): The name of the league as a string as it appears in
            the name of the folder the csv is located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.add_sided_wdl(league, years)
        df['Home_Points_Per_Game'] = (np.float64(
            df.Home_Team_Points) / (df.Round-1)).fillna(0)
        df['Home_Goals_Per_Game'] = (np.float64(
            df.Home_Team_Goals_For_This_Far) / (df.Round-1)).fillna(0)
        df['Home_Goals_Against_Per_Game'] = (np.float64(
            df.Home_Team_Goals_Against_This_Far) / (df.Round-1)).fillna(0)
        df['Home_Cards_Per_Game'] = (np.float64(
            df.Home_Team_Reds_This_Far + df.Home_Team_Yellows_This_Far) / (
                df.Round-1)).fillna(0)
        df['Away_Points_Per_Game'] = (np.float64(
            df.Away_Team_Points) / (df.Round-1)).fillna(0)
        df['Away_Goals_Per_Game'] = (np.float64(
            df.Away_Team_Goals_For_This_Far) / (df.Round-1)).fillna(0)
        df['Away_Goals_Against_Per_Game'] = (np.float64(
            df.Away_Team_Goals_Against_This_Far) / (df.Round-1)).fillna(0)
        df['Away_Cards_Per_Game'] = (np.float64(
            df.Away_Team_Reds_This_Far + df.Away_Team_Yellows_This_Far) / (
                df.Round-1)).fillna(0)
        return df.replace([np.inf, -np.inf], 0)

    def merge_data(self, leagues, years):
        '''
        This is a function to join the tables of each season and each year
        together and then to combine that with the information inside the
        team_info.csv file. It also adds data on whether an away side is
        playing on the same ground type as their home pitch.
        Attributes:
            leagues(List): A list of strings. The name of the leagues as they
            appear in the names of the folders their csvs are located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        team_info = pd.read_csv('Team_Info.csv')
        big_df = pd.DataFrame()
        for league in leagues:
            for year in (pbar2 := tqdm(years)):
                pbar2.set_description(f'Processing {league} {year}')
                df = self.add_per_games(league, year)
                big_df = pd.concat([big_df, df])
        big_df = pd.merge(big_df, team_info, on='Home_Team')
        pitches = []
        for row, value in big_df.iterrows():
            home_team_pitch = value['Pitch']
            away_team = value['Away_Team']
            try:
                away_pitch = team_info[team_info['Home_Team']
                                       == away_team].values[0][-1]
                if home_team_pitch == away_pitch:
                    pitches.append(1)
                else:
                    pitches.append(0)
            except IndexError:
                pitches.append(1)
        big_df['Pitch_Match'] = pitches
        return big_df

    def normalise_data(self, leagues, years):
        '''
        This is a function to add final cleaning to data created by the
        merge_data function. This includes: Substituting missing entries
        with zeroes, selecting only useful columns of the dataset, and
        substituting the match results for integers denoting each result.
        Attributes:
            leagues(List): A list of strings. The name of the leagues as they
            appear in the names of the folders their csvs are located in.
            years(List): A list of integers. The years of the later halves of
            each season that the function is to read the data of.
        '''
        df = self.merge_data(leagues, years)
        new_df = df.fillna(0)
        new_df.replace('Home_Team_Win', 2, inplace=True)
        new_df.replace('Draw', 1, inplace=True)
        new_df.replace('Away_Team_Win', 0, inplace=True)
        new_df = new_df[['Result', 'Season', 'Round', 'Teams_in_League',
                        'Home_Team_Goals_For_This_Far',
                         'Home_Team_Goals_Against_This_Far',
                         'Away_Team_Goals_For_This_Far',
                         'Away_Team_Goals_Against_This_Far',
                         'Home_Team_Points', 'Away_Team_Points',
                         'Home_Team_Losing_Streak', 'Away_Team_Losing_Streak',
                         'Home_Team_Winning_Streak',
                         'Away_Team_Winning_Streak',
                         'Home_Team_Unbeaten_Streak',
                         'Away_Team_Unbeaten_Streak',
                         'Elo_home', 'Elo_away', 'Home_Wins_This_Far',
                         'Home_Draws_This_Far', 'Home_Losses_This_Far',
                         'Away_Wins_This_Far', 'Away_Draws_This_Far',
                         'Away_Losses_This_Far', 'Home_Wins_This_Far_at_Home',
                         'Home_Draws_This_Far_at_Home',
                         'Home_Losses_This_Far_at_Home',
                         'Home_Wins_This_Far_Away',
                         'Home_Draws_This_Far_Away',
                         'Home_Losses_This_Far_Away',
                         'Away_Wins_This_Far_at_Home',
                         'Away_Draws_This_Far_at_Home',
                         'Away_Losses_This_Far_at_Home',
                         'Away_Wins_This_Far_Away',
                         'Away_Draws_This_Far_Away',
                         'Away_Losses_This_Far_Away',
                         'Capacity', 'Home_Yellow',
                         'Home_Team_Reds_This_Far',
                         'Home_Team_Yellows_This_Far',
                         'Away_Team_Reds_This_Far',
                         'Away_Team_Yellows_This_Far',
                         'Away_Red', 'Home_Points_Per_Game',
                         'Home_Goals_Per_Game',
                         'Home_Goals_Against_Per_Game',
                         'Home_Cards_Per_Game',
                         'Away_Points_Per_Game', 'Away_Goals_Per_Game',
                         'Away_Goals_Against_Per_Game',
                         'Away_Cards_Per_Game', 'Date_New',
                         'Link', 'Pitch_Match', 'League']]
        return new_df


class WebScraper:
    '''
    This is a class handling the scraping of the webpage
    besoccer.com for information regarding football matches.
    Attributes:
        leagues(List of Strings): a list containing the leagues that
        are desired to be scraped.
    '''

    def __init__(self, leagues) -> None:
        '''
        See help(WebScraper) for accurate signature.
        '''
        self.leagues = leagues
        self.league_names = [x['Name'] for x in leagues]

    def scrape_league_links(self, league, year, url_ext=''):
        '''
        This is a function to scrape links to football matches
        from besoccer.com from a specific year and league.
        Attributes:
            league(String): The name of the league as a string as it appears at
            the end of the besoccer.com url.
            year(Integer): The year of the later half of the season that the
            function is to scrape matches for.
            url_ext(String): '/group1' or other strings that are needed to be
            added to the url to ensure the scraper scrapes the main season
            rather than the playoffs or pre-season matches.
        '''
        match_links = []
        teams = teams_in_league(self.leagues, league)
        games = (teams - 1) * 2
        for i in range(1, games + 1):
            url = f'http://besoccer.com/competition/scores'\
                f'/{league}/{year}{url_ext}/round{i}'
            html = requests.get(url).text
            page = BeautifulSoup(html, 'html.parser')
            box = page.find(
                attrs={'class': "panel-body p0 match-list-new"})
            try:
                for a in box.find_all('a', href=True):
                    match_links.append([a['href'], i])
            except AttributeError:
                continue
        return match_links

    def scrape_all_leagues(self, leagues_and_exts, year):
        '''
        This is a function to scrape links to football matches
        from besoccer.com from a every desired league in a specified year.
        Attributes:
            leagues_and_exts(List): A list of lists. Each internal list should
            have two elements (both strings) - The first is the name of the
            league as it appears in the besoccer.cm url. The second is the
            url_ext required for the scraper to scrape the correct matches.
            year(Integer): The year of the later half of the season that the
            function is to scrape matches for.
        '''
        links = []
        for league in leagues_and_exts:
            link = self.scrape_league_links(
                league[0], year, url_ext=league[1])
            links.append(link)
        return links

    def scrape_page_info(self, url, league, year, round):
        '''
        This is a function to scrape relevant information from the
        besoccer.com webpage and to store that information as a dataframe
        and to later add it to the master table of football matches after
        the data has been cleaned.
        Attributes:
            url(String): Obtained from the scrape_all_leagues function or
            otherwise, this is a url pertaining to match data on the
            besoccer.com website.
            league(String): The name of the league as a string as it appears at
            the end of the besoccer.com url.
            year(Integer): The year of the later half of the season that the
            function is to scrape matches for.
            round(Integer): The round of play that the game takes place in.
            This is added by the scrape_league_data function for convenience as
            Round is an important data column.
        '''
        html = requests.get(url).text
        page = BeautifulSoup(html, 'html.parser')
        home_team = page.find(
            attrs={'itemprop': 'homeTeam'}).text.replace('\n', '')
        away_team = page.find(
            attrs={'itemprop': 'awayTeam'}).text.replace('\n', '')
        try:
            date = page.find(attrs={'class': 'date header-match-date'}).text
        except AttributeError:
            date = page.find(
                attrs={'class': 'date header-match-date no-hour'}).text
        date = clean_date(date)
        referee = None
        try:
            home_goals = page.find(
                attrs={'class': 'r1'}).text
            away_goals = page.find(
                attrs={'class': 'r2'}).text
        except AttributeError:
            goals = page.find(
                attrs={'class': 'data penaltis'}).text.split('\n')
            home_goals = return_number(goals[2])[0]
            away_goals = return_number(goals[2])[-1]
        result = f'{home_goals}-{away_goals}'
        home_yellow = 0
        away_yellow = 0
        home_red = 0
        away_red = 0
        try:
            table = page.find(attrs={'class': 'panel-body pn compare-data'})
            table = table.find('tbody')
            table = table.find_all('tr')
            for tr in table:
                if 'Yellow cards' in tr.text or 'Yellow card' in tr.text:
                    home_yellow = return_number(tr.text)[0]
                    away_yellow = return_number(tr.text)[1]
            for tr in table:
                if 'Red cards' in tr.text or 'Red card' in tr.text:
                    home_red = return_number(tr.text)[0]
                    away_red = return_number(tr.text)[0]
        except AttributeError:
            pass

        html = requests.get(f'{url}/analysis').text
        page = BeautifulSoup(html, 'html.parser')
        try:
            home_elo = page.find(
                attrs={'class': 'team1-c'}).find(attrs={
                    'class': 'rating'}).text
            away_elo = page.find(
                attrs={'class': 'team2-c'}).find(attrs={
                    'class': 'rating'}).text
        except AttributeError:
            home_elo = 50
            away_elo = 50

        data = {'Home_Team': [home_team], 'Away_Team': [away_team],
                'Result': [result], 'Link': [url], 'Season': [int(year)],
                'Round': [round], 'League': [league], 'Elo_home': [home_elo],
                'Elo_away': [away_elo], 'Home_Yellow': [home_yellow],
                'Home_Red': [home_red], 'Away_Yellow': [away_yellow],
                'Away_Red': [away_red], 'Date_New': [None],
                'Referee': [referee], 'Year': [year]}
        return pd.DataFrame.from_dict(data)

    def scrape_league_data(self, league, year, url_ext=''):
        '''
        This is a function to scrape relevant information from the
        besoccer.com webpage for an entire season in one league. This
        is to create a dataframe similar to the csv files initially given
        so that new seasons can be cleaned and added to the cleaned dataset.
        Attributes:
            league(String): The name of the league as a string as it appears at
            the end of the besoccer.com url.
            year(Integer): The year of the later half of the season that the
            function is to scrape matches for.
            url_ext(String): '/group1' or other strings that are needed to be
            added to the url to ensure the scraper scrapes the main season
            rather than the playoffs or pre-season matches.
        '''
        links = self.scrape_league_links(league, year, url_ext=url_ext)
        dfs = []
        for link in tqdm(links, desc='Scraping Matches'):
            dfs.append(self.scrape_page_info(link[0], league, year, link[1]))
        return pd.concat(dfs).reset_index(drop=True)

    def export_table(self, league, year, url_ext=''):
        '''
        This is a function to obtain scraped information about one
        football season in one year and to export that data as a csv file
        in an organised folder.
        Attributes:
            league(String): The name of the league as a string as it appears at
            the end of the besoccer.com url.
            year(Integer): The year of the later half of the season that the
            function is to scrape matches for.
            url_ext(String): '/group1' or other strings that are needed to be
            added to the url to ensure the scraper scrapes the main season
            rather than the playoffs or pre-season matches.
        '''
        df = self.scrape_league_data(league, year, url_ext=url_ext)
        path = f'data/{league}/Results_{year}_{league}.csv'
        df.to_csv(path, index=None)


def teams_in_league(leagues, league_name):
    '''
    This is a functions to return the number of teams that play in a
    specified league.
    Attributes:
        leagues(List of dictionaries): Specified at the beginning of
        the program, this is a list of dictionaries of the form
        {'Name': league_name, 'Teams': number_of_teams}.
        league_name(String): The name of the league as it appears in
        one of the leagues' dictionaries.
    '''
    teams = next(
        item for item in leagues if item['Name'] == league_name)
    return teams['Teams']


def return_number(string):
    '''
    This is a function to return only the numerical elements in a
    given string.
    Attributes:
        string(String): A string containing digits that need to be
        isolated.
    '''
    return ''.join(i for i in string if i.isdigit())


def clean_ref(string):
    '''
    This is a function to isolate a referee's name from the string
    it appears in, in the match_info.csv file.
    Attributes:
    string(String): A string from the Referee column of the
    match_info.csv file.
    '''
    return string.split('/')[0].strip('\r\n').strip('Referee: ')


def clean_date(string):
    '''
    This is a function to attempt to read the date of a football match
    from the besoccer.com webpage. This function tries to read 3
    different date formats and if unsuccessful returns the date as None.
    Attributes:
        string(String): A date string for the function to convert to a
        date object.
    '''
    try:
        date = datetime.strptime(string.replace(' ', ''), '%d%b%Y%H:%M')
    except ValueError:
        try:
            date = datetime.strptime(string.replace(' ', ''), '%a,%d%b%H:%M')
        except ValueError:
            try:
                date = datetime.strptime(string.replace(' ', ''), '%a,%d%b')
            except ValueError:
                date = None
    return date


def update_link(string):
    '''
    This is a function to convert a website url to a useful unique link
    to be used as a database ID.
    Attributes:
        string(String): The latter part of a besoccer.com url that
        distinguishes it from other urls
    '''
    return 'https://www.besoccer.com' + string


def change_date(string):
    '''
    This is a function to amend the date as it appears in the
    match_info.csv file.
    Attributes:
        string(String): A string from the Date_New column of the
        match_info.csv file.
    '''
    string = re.sub(', ..:..', '', string)
    return datetime.strptime(string, '%A, %d %B %Y')


def modify_link(string):
    '''
    This is a function to amend the link as it appears in the
    leagues' csv files.
    Attributes:
        string(String): A string from the Link column of the
        leagues' file.
    '''
    year = string.split('/')[-1][:4]
    end = len(string.split('/')[-1])
    return string[:-end] + year


def team_table(df, team):
    '''
    This is a function that returns matches from a cleaned dataset
    where only a named team played.
    Attributes:
        df(pd.DataFrame): The dataframe of football matches
        generated by the clean data function.
        team(String): The name of the team to find the matches
        of in a specific season.
    '''
    return df[(df['Home_Team'] == team) | (df['Away_Team'] == team)]


if __name__ == '__main__':
    '''
    histogram('premier_league', 2003)
    bar_graph('premier_league', 2003)
    for league in leagues:
        wp_graph(league['Name'], years)
    '''
    cleaner = DataCleaner(leagues, years)
    scraper = WebScraper(leagues)
    league_names = [x['Name'] for x in leagues]
    x = cleaner.normalise_data(league_names, years)
    x.to_csv('cleaned_dataset.csv', index=False)
